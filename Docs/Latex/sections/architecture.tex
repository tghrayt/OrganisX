\chapter{Architecture}

L’architecture du projet \textbf{OrganisX} constitue la fondation sur laquelle reposent toutes les fonctionnalités, la qualité et l’évolutivité du système. Elle a été conçue pour répondre aux besoins suivants :
\begin{itemize}
	\item Séparer clairement le \textbf{cœur métier} des préoccupations techniques.
	\item Assurer une \textbf{testabilité élevée} et faciliter la maintenance.
	\item Permettre une \textbf{évolution progressive} vers des solutions distribuées et scalables (microservices, cloud).
	\item Favoriser l’\textbf{adaptabilité technologique} (pouvoir remplacer une base de données, un framework, une librairie sans réécrire la logique métier).
\end{itemize}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{images/architecture.png}
	\caption{Architecture globale du projet OrganisX}
	\label{fig:architecture}
\end{figure}

\section{Philosophie générale}
Le projet adopte une approche \textbf{hexagonale} (également appelée \textit{Ports \& Adapters}).  
Cette architecture permet d’organiser le code autour de son \textbf{domaine métier}, tout en rendant les dépendances techniques secondaires et interchangeables.  
En pratique, cela signifie que le cœur applicatif (les règles métier et les cas d’utilisation) ne dépend d’aucune technologie particulière, mais uniquement d’interfaces (ports). Les implémentations concrètes (adapters) se trouvent en périphérie.

\newpage
\section{Structure Backend}
Le backend est développé en \textbf{.NET 9} et adopte une organisation orientée \textbf{microservices}, tout en respectant les principes de l’architecture hexagonale.  
Chaque service est indépendant, possède sa propre base de données et expose une API REST.  

Les microservices principaux sont :  
\begin{itemize}
	\item \texttt{OrganisX.AuthService} :
	\begin{itemize}
		\item Gestion de l’authentification et de l’autorisation via \textbf{JWT}.
		\item Contient les entités liées aux utilisateurs (User, Role).
		\item Peut être remplacé à terme par une solution externe (Azure AD, Keycloak).
	\end{itemize}
	
	\item \texttt{OrganisX.TaskService} :
	\begin{itemize}
		\item Gestion du cycle de vie des tâches (création, assignation, suivi).
		\item Implémente les règles métier associées (une tâche doit avoir un responsable, des deadlines, etc.).
	\end{itemize}
	
	\item \texttt{OrganisX.TeamService} :
	\begin{itemize}
		\item Gestion des équipes et des relations entre membres.
		\item Coordination avec \texttt{TaskService} pour affecter les tâches aux bons utilisateurs.
	\end{itemize}
	
	\item \texttt{OrganisX.ReportingService} (optionnel/futur) :
	\begin{itemize}
		\item Génération de rapports (productivité, suivi des tâches).
		\item Peut consommer des événements provenant des autres microservices.
	\end{itemize}
\end{itemize}

Chaque microservice respecte la structure interne suivante (dérivée de l’architecture hexagonale) :  
\begin{itemize}
	\item \textbf{Domain} : entités métier et invariants.
	\item \textbf{Application} : cas d’utilisation.
	\item \textbf{Infrastructure} : persistance, messaging (RabbitMQ/Azure Service Bus), accès API externes.
	\item \textbf{Api} : contrôleurs REST exposant les fonctionnalités.
\end{itemize}

La communication entre microservices peut se faire :  
\begin{itemize}
	\item en \textbf{synchrones} (API REST) pour les appels directs,
	\item en \textbf{asynchrones} (bus de messages) pour les événements métier (ex. création d’une tâche notifiant le service d’équipe).
\end{itemize}


\texttt{Domain}, \texttt{Application}, \texttt{Infrastructure} et \texttt{Api}.  

\begin{forest}
	for tree={
		font=\ttfamily,
		grow'=0,
		child anchor=west,
		parent anchor=south,
		anchor=west,
		calign=first,
		edge path={
			\noexpand\path [draw, \forestoption{edge}] (!u.south west) +(7.5pt,0) |- (.child anchor)\forestoption{edge label};
		},
		before typesetting nodes={
			if n=1
			{insert before={[,phantom]}}
			{}
		},
		fit=band,
		before computing xy={l=15pt},
	}
	[/backend
	[AuthService
	[AuthService.Domain]
	[AuthService.Application]
	[AuthService.Infrastructure]
	[AuthService.Api]
	]
	[TodoService
	[TodoService.Domain]
	[TodoService.Application]
	[TodoService.Infrastructure]
	[TodoService.Api]
	]
	[NotificationService
	[NotificationService.Domain]
	[NotificationService.Application]
	[NotificationService.Infrastructure]
	[NotificationService.Api]
	]
	[Shared
	[Shared]
	]
	]
\end{forest}

Cette organisation respecte le principe de \textbf{dépendances dirigées vers l’intérieur} : seul le domaine est indépendant, tandis que l’infrastructure dépend de l’application et du domaine.

\section{Structure Frontend}
Le frontend est conçu en \textbf{Angular 20}. Il constitue la porte d’entrée utilisateur vers les fonctionnalités d’OrganisX.  
Son organisation repose sur les principes suivants :
\begin{itemize}
	\item \textbf{Modules fonctionnels} : chaque domaine métier (authentification, gestion des tâches, gestion des équipes) est isolé dans un module Angular.
	\item \textbf{Services Angular} : centralisation de la logique de communication avec le backend via l’API REST.
	\item \textbf{Composants UI} : interfaces réactives permettant une bonne expérience utilisateur.
	\item \textbf{State management} (si besoin futur) : possibilité d’introduire NgRx pour gérer des flux complexes d’état.
\end{itemize}

\begin{forest}
	for tree={
		font=\ttfamily,
		grow'=0,
		child anchor=west,
		parent anchor=south,
		anchor=west,
		calign=first,
		edge path={
			\noexpand\path [draw, \forestoption{edge}] (!u.south west) +(7.5pt,0) |- (.child anchor)\forestoption{edge label};
		},
		before typesetting nodes={
			if n=1
			{insert before={[,phantom]}}
			{}
		},
		fit=band,
		before computing xy={l=15pt},
	}
	[/frontend
	[src/app
	[auth
	[login]
	[register]
	]
	[todos
	[task-list]
	[task-detail]
	[project-view]
	]
	[notifications
	[notification-list]
	]
	[shared
	[components]
	[services]
	]
	[core
	[interceptors]
	[guards]
	[api-clients]
	]
	]
	]
\end{forest}

\section{Communication Frontend/Backend}
L’interaction entre le frontend et le backend se fait via une \textbf{API RESTful}, en utilisant le format \textbf{JSON}.  
Quelques caractéristiques principales :
\begin{itemize}
	\item \textbf{Authentification} : sécurisée par \textbf{JWT}.
	\item \textbf{Endpoints REST} exposant les cas d’utilisation (ex. \texttt{POST /tasks}, \texttt{GET /teams}).
	\item \textbf{Validation et erreurs} : centralisées dans le backend et renvoyées au frontend pour affichage clair.
\end{itemize}

\section{Architecture microservices dès le MVP}
Le projet adopte directement une \textbf{architecture microservices}, afin d’assurer une meilleure séparation des responsabilités, une évolutivité indépendante des modules et une meilleure résilience.  

Les services principaux prévus dès le MVP sont :
\begin{itemize}
	\item \textbf{AuthService} : gestion des utilisateurs, inscription, connexion et génération de tokens JWT.
	\item \textbf{TaskService} : gestion des tâches (création, mise à jour, suppression, consultation).
\end{itemize}

La communication entre les services s’effectue via des \textbf{API REST sécurisées}.  
À terme, l’architecture pourra intégrer une communication \textbf{asynchrone par messages} (RabbitMQ, Azure Service Bus, Kafka) pour gérer des flux plus complexes.  

Cette approche permet de garantir dès le départ :
\begin{itemize}
	\item Une \textbf{scalabilité indépendante} (chaque microservice peut être déployé et scalé séparément).
	\item Une \textbf{flexibilité technologique} (chaque service peut évoluer indépendamment avec ses propres choix techniques).
	\item Une \textbf{résilience accrue} (panne d’un service n’entraîne pas la chute du système global).
\end{itemize}

\section{Communication entre microservices}
La communication entre microservices est un élément clé de l’architecture. Dans le cadre du \textbf{MVP 1}, le choix s’oriente vers une \textbf{communication synchrone via API REST sécurisées}, afin de privilégier la simplicité de mise en œuvre. Chaque service expose ses fonctionnalités sous forme d’API documentées (ex. Swagger / OpenAPI).  

\subsection{Communication synchrone}
\begin{itemize}
	\item Les microservices communiquent via \textbf{HTTP/HTTPS} avec des formats standards comme \textbf{JSON}.
	\item Un \textbf{API Gateway} (optionnel au MVP) peut être introduit pour centraliser l’accès aux différents services, gérer l’authentification et appliquer des règles de routage.
	\item Exemple : le \textbf{TaskService} vérifie auprès de l’\textbf{AuthService} si un utilisateur est authentifié avant de permettre la création d’une tâche.
\end{itemize}

\subsection{Communication asynchrone (prévue pour les évolutions futures)}
Afin d’assurer la scalabilité et la résilience, une communication asynchrone pourra être mise en place dans les versions ultérieures :
\begin{itemize}
	\item Utilisation de \textbf{message brokers} tels que \textbf{RabbitMQ}, \textbf{Kafka} ou \textbf{Azure Service Bus}.
	\item Gestion d’événements métiers (\textit{UserRegistered}, \textit{TaskCreated}, \textit{TaskCompleted}, etc.).
	\item Permet de découpler davantage les microservices et d’améliorer la \textbf{tolérance aux pannes}.
\end{itemize}

\subsection{Gestion des contrats et documentation}
\begin{itemize}
	\item Chaque microservice expose un \textbf{contrat d’API} clair (OpenAPI/Swagger).
	\item La documentation est versionnée avec le code source pour garantir la cohérence.
	\item Les tests d’intégration incluent des vérifications de compatibilité entre services.
\end{itemize}

Ainsi, le système combine une \textbf{approche simple et pragmatique au démarrage} avec la possibilité d’évoluer vers des \textbf{communications asynchrones robustes} lorsque les besoins l’exigeront.


\section{Monitoring et observabilité}
Afin de garantir la fiabilité et la maintenabilité du système, une stratégie de \textbf{monitoring centralisé} est mise en place dès le MVP. L’outil choisi est \textbf{Telemetry BetterStack}, qui permet de collecter, centraliser et analyser les logs provenant des différents microservices.

\subsection{Collecte des logs}
\begin{itemize}
	\item Chaque microservice est configuré pour envoyer ses \textbf{logs applicatifs} (ex. erreurs, requêtes entrantes, événements métiers) vers la plateforme BetterStack.
	\item Les logs sont structurés au format \textbf{JSON} pour faciliter leur exploitation.
	\item Les logs sensibles (mots de passe, tokens, données personnelles) sont systématiquement masqués avant l’envoi.
\end{itemize}

\subsection{Suivi de la performance et alertes}
\begin{itemize}
	\item BetterStack permet de \textbf{surveiller les métriques clés} : temps de réponse des API, nombre d’erreurs, taux de succès.
	\item Mise en place de \textbf{seuils d’alerte} (ex. temps de réponse > 2s, taux d’erreurs > 5\%) déclenchant des notifications (email, Slack, etc.).
	\item Les tableaux de bord offrent une vue consolidée de l’état des microservices.
\end{itemize}

\subsection{Traçabilité des requêtes}
\begin{itemize}
	\item Un \textbf{correlation ID} unique est généré pour chaque requête utilisateur et propagé entre les microservices.
	\item Cela permet de tracer le parcours complet d’une requête (de l’AuthService au TaskService, etc.) et de faciliter le \textbf{debugging}.
\end{itemize}

\subsection{Évolutions futures}
\begin{itemize}
	\item Intégration possible avec des solutions de \textbf{metrics} et \textbf{APM} (Application Performance Monitoring) comme Prometheus ou Grafana.
	\item Mise en place de \textbf{tracing distribué} via OpenTelemetry pour analyser en profondeur les appels entre microservices.
\end{itemize}

Ainsi, dès le MVP, le projet bénéficie d’une solution robuste pour la \textbf{collecte de logs et le suivi en temps réel}, garantissant une détection rapide des anomalies et une maintenance proactive.


